#!/usr/bin/env python3
#
# @mebeim - 2025-09-07
#

from abc import abstractmethod
from collections import defaultdict
from hashlib import sha1, sha256
from itertools import cycle
from pathlib import Path
from random import Random


FLAG = b'7H3_V4CUUM_0F_SP4C3_D035_N07_F0RG1V3_Y0U_317H3R_SH007_0R_5H4773R'
RNG_SEED = b'omegalul'


def xor_bytes(ptx: bytes, key: bytes) -> bytes:
	return bytes(bytearray(p ^ k for p, k in zip(ptx, cycle(key))))


def repeat_bytes(src: bytes, len: int) -> bytes:
	it = iter(cycle(src))
	return bytes(bytearray(next(it) for _ in range(len)))


def c_array(data: bytes):
	return '{' + ', '.join(map('0x{:02x}'.format, data)) + '}'


class Achievement:
	rng: Random
	key: bytes
	flag_fragment: bytes
	enc_flag_fragment: bytes

	def __init__(self, flag: bytes, idxs: set[int], rng: Random):
		self.rng = rng
		self.flag_fragment = b''

		for i in range(len(flag)):
			if i in idxs:
				self.flag_fragment += flag[i:i + 1]
			else:
				self.flag_fragment += b'*'

		self.key = self._gen_key()
		self.enc_flag_fragment = xor_bytes(self.flag_fragment, self.key)

	@abstractmethod
	def _gen_key(self) -> bytes:
		return NotImplemented

	@abstractmethod
	def gen_params_header(self) -> str:
		return NotImplemented

	def _gen_achieve_call_tree(self, tree: dict[str, list[str]], root: str) -> list[str]:
		byte_idxs: dict[str,int] = {}

		def dfs(cur: str, byte_idx: int=0) -> int:
			byte_idxs[cur] = byte_idx
			byte_idx += 1

			for child in tree[cur]:
				byte_idx = dfs(child, byte_idx)

			return byte_idx

		dfs(root)

		lines = []
		for func, byte_idx in byte_idxs.items():
			enc_byte = self.enc_flag_fragment[byte_idx]
			lines.extend([
				f'static void __attribute__((noinline)) {func}(char *value, const uint8_t *key, size_t key_len, size_t *idx) {{',
				f'	value[*idx] = (char)(0x{enc_byte:02x} ^ key[*idx % key_len]);',
				'	(*idx)++;',
			])

			for child in tree[func]:
				lines.append(f'\t{child}(value, key, key_len, idx);')
			lines.extend(['}', ''])

		return lines

	def gen_achieve_method(self) -> str:
		clazz = self.__class__.__name__
		functions: list[tuple[int, str]] = []
		tree = defaultdict(list)
		lines: list[str] = [
			'/* Auto-generated by gen_achievements.py */',
			'',
			'#include <cstdint>',
			'#include <cstddef>',
			f'#include "{clazz}.h"',
			'',
			'extern "C" {',
			'',
		]

		for _ in range(len(self.flag_fragment)):
			name = 'f' + self.rng.randbytes(8).hex()
			assert name not in functions
			functions.append(name)
			lines.append(f'static void {name}(char *, const uint8_t *, size_t, size_t *);')
		lines.append('')

		for i, child in enumerate(functions[1:], 1):
			# Choose parent func among previous 8
			lo = max(0, i - 8)
			hi = i - 1
			parent = functions[self.rng.randint(lo, hi)]
			tree[parent].append(child)

		root = functions[0]
		lines.extend(self._gen_achieve_call_tree(tree, root))

		lines.extend([
			'} // extern "C"',
			'',
			'using namespace asteroids;',
			'',
			f'void {clazz}::achieve(const uint8_t *key, size_t key_len) {{',
			f'	char value[{len(self.flag_fragment)} + 1] = {{0}};',
			'	size_t idx = 0;',
			f'	{root}(value, key, key_len, &idx);',
			'	achieved_ = true;',
			'	emit_signal("achieved", get_name(), godot::String(value));',
			'	queue_free();',
			'}',
		])

		return '\n'.join(lines) + '\n'


class Achievement01AsteroidSmasher(Achievement):
	'''
	Explode a total of 100 asteroids of any kind. Check against hardcoded value.
	Decrypt flag fragment via xor with hardcoded key.
	'''
	n: int = 100

	def _gen_key(self) -> bytes:
		return self.rng.randbytes(len(self.flag_fragment))

	def gen_params_header(self) -> str:
		return '\n'.join([
			'/* Auto-generated by gen_achievements.py */',
			'#pragma once',
			f'// Flag fragment: {self.flag_fragment.decode()}',
			f'// Key: {self.key.hex()}',
			f'// Asteroids to explode: {self.n}',
			f'#define ASTEROIDS_EXPLODED_EASY_N {self.n}',
			f'#define ASTEROIDS_EXPLODED_EASY_KEY {c_array(self.key)}',
		]) + '\n'


class Achievement02AsteroidAnnihilator(Achievement):
	'''
	Explode a total of N asteroids of any kind where N is randomly generated
	between 1000 and 2000. Check against SHA1 of stringified N. Derive key
	from SHA256 of stringified N.
	'''
	n: int
	sha1_hash: bytes

	def _gen_key(self) -> bytes:
		self.n = self.rng.randint(1000, 2000)
		n_bytes = str(self.n).encode()
		self.sha1_hash = sha1(n_bytes).digest()
		sha256_hash = sha256(n_bytes).digest()
		return repeat_bytes(sha256_hash, len(self.flag_fragment))

	def gen_params_header(self) -> str:
		return '\n'.join([
			'/* Auto-generated by gen_achievements.py */',
			'#pragma once',
			f'// Flag fragment: {self.flag_fragment.decode()}',
			f'// Key: {self.key.hex()}',
			f'// Asteroids to explode: {self.n}',
			f'#define ASTEROIDS_EXPLODED_HARD_SHA1 {c_array(self.sha1_hash)}',
		]) + '\n'


class Achievement03InterstellarCheater(Achievement):
	'''
	Check against hardcoded cheat code. Decrypt flag fragment via xor with
	hardcoded key.
	'''
	cheat_code: bytes = b'METEORITE'

	def _gen_key(self) -> bytes:
		return self.rng.randbytes(len(self.flag_fragment))

	def gen_params_header(self) -> str:
		return '\n'.join([
			'/* Auto-generated by gen_achievements.py */',
			'#pragma once',
			f'// Flag fragment: {self.flag_fragment.decode()}',
			f'// Key: {self.key.hex()}',
			f'// Cheat code: {self.cheat_code.decode()}',
			f'#define CHEAT_CODE_EASY_CODE {c_array(self.cheat_code)}',
			f'#define CHEAT_CODE_EASY_KEY {c_array(self.key)}',
		]) + '\n'


class Achievement04InterstellarHacker(Achievement):
	'''
	Check against SHA1 of cheat code. Derive key from SHA256 of cheat code.
	'''
	cheat_code: bytes = b'ALIEN'
	sha1_hash: bytes

	def _gen_key(self) -> bytes:
		self.sha1_hash = sha1(self.cheat_code).digest()
		sha256_hash = sha256(self.cheat_code).digest()
		return repeat_bytes(sha256_hash, len(self.flag_fragment))

	def gen_params_header(self) -> str:
		return '\n'.join([
			'/* Auto-generated by gen_achievements.py */',
			'#pragma once',
			f'// Flag fragment: {self.flag_fragment.decode()}',
			f'// Key: {self.key.hex()}',
			f'// Cheat code: {self.cheat_code.decode()}',
			f'#define CHEAT_CODE_HARD_LEN {len(self.cheat_code)}',
			f'#define CHEAT_CODE_HARD_SHA1 {c_array(self.sha1_hash)}',
		]) + '\n'


class Achievement05RookieNumbers(Achievement):
	'''
	Check against hardcoded score target. Decrypt flag fragment via xor of
	hardcoded key.
	'''
	target_score: int = 50000

	def _gen_key(self) -> bytes:
		return self.rng.randbytes(len(self.flag_fragment))

	def gen_params_header(self) -> str:
		return '\n'.join([
			'/* Auto-generated by gen_achievements.py */',
			'#pragma once',
			f'// Flag fragment: {self.flag_fragment.decode()}',
			f'// Key: {self.key.hex()}',
			f'// Target score: {self.target_score}',
			f'#define SCORE_EASY_TARGET {self.target_score}',
			f'#define SCORE_EASY_KEY {c_array(self.key)}',
		]) + '\n'


class Achievement06Sharpshooter(Achievement):
	'''
	Explode in sequence: 3 big, 3 medium, 3 small asteroids. Record subsequent
	score deltas. Check against SHA1 of deltas as stringified int array (e.g.
	"[1, 2, 3]"). Derive key from SHA256 of same stringified int array.
	'''
	score_deltas: list[int] = [25, 25, 25, 50, 50, 50, 100, 100, 100]
	sha1_hash: bytes

	def _gen_key(self) -> bytes:
		# Stringified array should be same as Python repr
		arr_str = repr(self.score_deltas).encode()
		self.sha1_hash = sha1(arr_str).digest()
		sha256_hash = sha256(arr_str).digest()
		return repeat_bytes(sha256_hash, len(self.flag_fragment))

	def gen_params_header(self) -> str:
		return '\n'.join([
			'/* Auto-generated by gen_achievements.py */',
			'#pragma once',
			f'// Flag fragment: {self.flag_fragment.decode()}',
			f'// Key: {self.key.hex()}',
			f'// Score deltas: {self.score_deltas}',
			f'#define SCORE_HARD_N_DELTAS {len(self.score_deltas)}',
			f'#define SCORE_HARD_CTX {c_array(self.enc_flag_fragment)}',
			f'#define SCORE_HARD_SHA1 {c_array(self.sha1_hash)}',
		]) + '\n'


class Achievement07WarpSpeed(Achievement):
	'''
	Maintain a player velocity >= 300 (vector magnitude) for 10 seconds. Check
	against hardcoded value. Decrypt flag fragment via xor with hardcoded key.
	'''
	velocity: float = 300
	time: float = 10

	def _gen_key(self) -> bytes:
		return self.rng.randbytes(len(self.flag_fragment))

	def gen_params_header(self) -> str:
		return '\n'.join([
			'/* Auto-generated by gen_achievements.py */',
			'#pragma once',
			f'// Flag fragment: {self.flag_fragment.decode()}',
			f'// Key: {self.key.hex()}',
			f'// Target velocity (modulus): {self.velocity:.2f}',
			f'// Time to hold: {self.time:.2f}',
			f'#define SPEED_TARGET {self.velocity:.02f}',
			f'#define SPEED_TIME {self.time:.02f}',
			f'#define SPEED_KEY {c_array(self.key)}',
		]) + '\n'


class Achievement08Survivor(Achievement):
	'''
	Survive for 600 seconds (10 min). Check against SHA1 of elapsed time rounded
	to seconds. Derive key from SHA256 of stringified time value.
	'''
	time: float = 600

	def _gen_key(self) -> bytes:
		time_bytes = str(self.time).encode()
		self.sha1_hash = sha1(time_bytes).digest()
		sha256_hash = sha256(time_bytes).digest()
		return repeat_bytes(sha256_hash, len(self.flag_fragment))

	def gen_params_header(self) -> str:
		return '\n'.join([
			'/* Auto-generated by gen_achievements.py */',
			'#pragma once',
			f'// Flag fragment: {self.flag_fragment.decode()}',
			f'// Key: {self.key.hex()}',
			f'// Time to survive: {self.time}',
			f'#define TIME_EASY_SHA1 {c_array(self.sha1_hash)}',
		]) + '\n'


class Achievement09Immortal(Achievement):
	'''
	Survive for 3600 seconds (1h). Check against SHA1 of elapsed time rounded
	to seconds. Derive key from SHA256 of stringified time value.
	'''
	time: float = 3600

	def _gen_key(self) -> bytes:
		time_bytes = str(self.time).encode()
		self.sha1_hash = sha1(time_bytes).digest()
		sha256_hash = sha256(time_bytes).digest()
		return repeat_bytes(sha256_hash, len(self.flag_fragment))

	def gen_params_header(self) -> str:
		return '\n'.join([
			'/* Auto-generated by gen_achievements.py */',
			'#pragma once',
			f'// Flag fragment: {self.flag_fragment.decode()}',
			f'// Key: {self.key.hex()}',
			f'// Time to survive: {self.time}',
			f'#define TIME_HARD_SHA1 {c_array(self.sha1_hash)}',
		]) + '\n'


ACHIEVEMENTS: list[type[Achievement]] = [
	Achievement01AsteroidSmasher,
	Achievement02AsteroidAnnihilator,
	Achievement03InterstellarCheater,
	Achievement04InterstellarHacker,
	Achievement05RookieNumbers,
	Achievement06Sharpshooter,
	Achievement07WarpSpeed,
	Achievement08Survivor,
	Achievement09Immortal,
]


def main():
	mydir = Path(__file__).parent
	rng = Random(RNG_SEED)
	flag_idxs = list(range(len(FLAG)))
	rng.shuffle(flag_idxs)

	chars_per_achievement = len(FLAG) // len(ACHIEVEMENTS)
	achievement_idxs = []

	for i in range(0, len(FLAG), chars_per_achievement):
		achievement_idxs.append(set(flag_idxs[i:i + chars_per_achievement]))

	# Remainder (if any) goes to last achievement
	if len(achievement_idxs) > len(ACHIEVEMENTS):
		rem = achievement_idxs.pop()
		achievement_idxs[-1] |= rem

	assert sum(map(len, achievement_idxs)) == len(FLAG), 'Bad flag split'

	for A, idxs in zip(ACHIEVEMENTS, achievement_idxs):
		a = A(FLAG, idxs, rng)

		path: Path = mydir / f'achievements/{A.__name__}_achieve.cc'
		with path.open('w') as f:
			f.write(a.gen_achieve_method())

		path = mydir / f'achievements/{A.__name__}_params.h'
		with path.open('w') as f:
			f.write(a.gen_params_header())


if __name__ == '__main__':
	main()
